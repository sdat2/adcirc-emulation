"""Generate hurricane."""
import os
from typing import Tuple, List
import datetime
import numpy as np
import xarray as xr
import matplotlib.pyplot as plt
import climada.hazard.trop_cyclone as tc
from src.constants import FIGURE_PATH, NEW_ORLEANS, NO_BBOX
from sithom.plot import plot_defaults, label_subplots
from sithom.place import Point
from src.data_loading.ibtracs import katrina, prep_for_climada

MODEL_VANG = {"H08": 0, "H1980": 1, "H10": 2}


def make_katrina_windfields(model: str = "H08") -> Tuple[np.ndarray]:
    """
    Make Katrina Windfields for input.

    Args:
        model (str): e.g. "H08"

    Returns:
        Tuple[np.ndarray]: The tuple of outputs (output, nodes)
    """
    centroids = np.array(
        [
            [x, y]
            for x in np.linspace(*NO_BBOX.lat, num=50)
            for y in np.linspace(*NO_BBOX.lon, num=50)
        ]
    )
    return tc.compute_windfields(
        prep_for_climada(katrina()),
        centroids,
        tc.MODEL_VANG[model],  # metric="equirect"
    )


def plot_katrina_windfield_example(model: str = "H08") -> None:
    """
    Plot the Katrina windfield that would
    be generated by `climada` using the Holland Hurricane Model.

    Args:
        model (str, optional): Model output. Defaults to "H08".
    """
    plot_defaults()
    output = make_katrina_windfields(model=model)
    _, axs = plt.subplots(2, 1, sharex=True)
    axs[0].plot(output[0][50, :, 0])
    axs[0].set_ylabel("x-wind [m s$^{-1}$]")
    axs[1].plot(output[0][50, :, 1])
    axs[1].set_ylabel("y-wind [m s$^{-1}$]")
    axs[1].set_xlabel("Node")
    label_subplots(axs)
    plt.savefig(os.path.join(FIGURE_PATH, "katrina-" + model + "-windfields.png"))
    plt.clf()


class HollandTropicalCyclone:
    def __init__(
        self,
        point: Point,
        angle: float,
        trans_speed: float,
        vmax: float,
        rmax: float,
        bs: float,
    ) -> None:
        """
        Holland tropical cylone to hit coast at point.

        Args:
            point (Point): Point to impact.
            angle (float): Angle to point.
            trans_speed (float): Translation speed.
            vmax (float): Wind velocity maximum.
            rmax (float): Radius of maximum wind.
            bs (float): Holland b parameter.
        """
        # print(angle, trans_speed)
        self.point = point
        self.angle = angle
        self.trans_speed = trans_speed
        self.vmax = vmax
        self.rmax = rmax
        self.bs = bs
        self.time_delta = datetime.timedelta(hours=4)
        self.impact_time = datetime.datetime(year=2005, month=8, day=28)

    def __repr__(self) -> str:
        return str(
            "point: "
            + str(self.point)
            + "\n"
            + "angle: "
            + str(self.angle)
            + " degrees\n"
            + "trans_speed: "
            + str(self.trans_speed)
            + " ms-1\n"
            + "vmax: "
            + str(self.vmax)
            + " ms-1\n"
            + "rmax: "
            + str(self.rmax)
            + " km\n"
            + "bs: "
            + str(self.bs)
            + " units\n"
        )

    def new_point(self, distance: float) -> List[float]:
        """
        Line.

        Args:
            distance (float): Distance in meters.

        Returns:
            List[float, float]: lon, lat
        """
        return [
            self.point.lon + np.sin(np.radians(self.angle)) * distance / 111e3,
            self.point.lat + np.cos(np.radians(self.angle)) * distance / 111e3,
        ]

    def trajectory(self, run_up=1e6, run_down=3.5e5) -> Tuple[np.ndarray, np.ndarray]:
        """
        Trajectory.

        Args:
            run_up (int, optional): Run up afterwards. Defaults to 1000 km in meteres.
            run_down (int, optional): Run down after point. Defaults to 350 km im meters.
        """
        distance_per_timestep = (
            self.trans_speed * self.time_delta / datetime.timedelta(seconds=1)
        )
        time_steps_before = int(abs(run_up) /distance_per_timestep)
        time_steps_after = int(abs(run_down) / distance_per_timestep)
        # print(self.point, self.angle, run_up, run_down)
        point_list = [
            self.new_point(dist)
            for dist in range(-int(run_up), int(run_down), int(distance_per_timestep))
        ]
        time_list = [
            self.impact_time + x * self.time_delta
            for x in range(
                -time_steps_before,
                time_steps_after + 2,
                1,
            )
        ]
        print(time_steps_before + time_steps_after + 1)
        return np.array(point_list), np.array(time_list)

    # def time_traj(self, )
    def trajectory_ds(self, run_up=1e6, run_down=3.5e5) -> xr.Dataset:
        traj, dates = self.trajectory(run_up=run_up, run_down=run_down)
        print(traj.shape)
        print(dates.shape)
        return xr.Dataset(
            data_vars=dict(
                lon=(["time"], traj[:, 0]),
                lat=(["time"], traj[:, 1]),
            ),
            coords=dict(
                time=dates,
                reference_time=self.impact_time,
            ),
            attrs=dict(description="Tropcial Cylone trajectory."),
        )


if __name__ == "__main__":
    # for key in tc.MODEL_VANG:
    #    plot_katrina_windfield_example(model=key)
    # plot_katrina_windfield_example(model="H08")
    # python src/models/generate-hurricane.py
    print("ok")
